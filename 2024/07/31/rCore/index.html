<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>rCore-Tutorial follow the riscv trend!!! | uloveRock?</title><meta name="author" content="luvroc"><meta name="copyright" content="luvroc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的博客地址：uloveRock? - God knows… welcome！  rCore-ch1环境执行fn main() &#123;    println!(&quot;hello,world&quot;);&#125;  从修改hello world，使它不用系统自带的依赖开始  修改目标平台目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库">
<meta property="og:type" content="article">
<meta property="og:title" content="rCore-Tutorial follow the riscv trend!!!">
<meta property="og:url" content="http://luvroc.github.io/2024/07/31/rCore/">
<meta property="og:site_name" content="uloveRock?">
<meta property="og:description" content="我的博客地址：uloveRock? - God knows… welcome！  rCore-ch1环境执行fn main() &#123;    println!(&quot;hello,world&quot;);&#125;  从修改hello world，使它不用系统自带的依赖开始  修改目标平台目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://q1.qlogo.cn/g?b=qq&nk=2316139590&s=640">
<meta property="article:published_time" content="2024-07-30T18:35:00.000Z">
<meta property="article:modified_time" content="2024-09-26T11:30:11.199Z">
<meta property="article:author" content="luvroc">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="Embedded">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://q1.qlogo.cn/g?b=qq&nk=2316139590&s=640"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://luvroc.github.io/2024/07/31/rCore/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'rCore-Tutorial follow the riscv trend!!!',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-26 19:30:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="uloveRock?"><span class="site-name">uloveRock?</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">rCore-Tutorial follow the riscv trend!!!</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-30T18:35:00.000Z" title="发表于 2024-07-31 02:35:00">2024-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-26T11:30:11.199Z" title="更新于 2024-09-26 19:30:11">2024-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Embedded-system/">Embedded system</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Embedded-system/Rust/">Rust</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="rCore-Tutorial follow the riscv trend!!!"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>我的博客地址：<a target="_blank" rel="noopener" href="https://loverock.life/">uloveRock? - God knows…</a></p>
<p>welcome！</p>
</blockquote>
<h3 id="rCore-ch1"><a href="#rCore-ch1" class="headerlink" title="rCore-ch1"></a>rCore-ch1</h3><h4 id="环境执行"><a href="#环境执行" class="headerlink" title="环境执行"></a>环境执行</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从修改hello world，使它不用系统自带的依赖开始</p>
<ol>
<li>修改目标平台<br>目标为裸机平台,没有rust标准库和os支持的系统调用,为了方便换上了rust的core库</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/.cargo/config</span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>移除标准库依赖<br>在main.rs中修改如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">	<span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同级目录新建一个lang_items.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此便移除了所有标准库依赖,可尝试<code>cargo build</code>看看全新的程序了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file /path/to/elf</span><br><span class="line"><span class="comment"># 可看文件格式</span></span><br><span class="line">rust-readobj -h /path/to/elf</span><br><span class="line"><span class="comment"># 可看详细的文件头信息</span></span><br><span class="line">rust-objdump -S /path/to/elf</span><br><span class="line"><span class="comment"># 可看反汇编导出的汇编程序</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/..%5Cpics%5Cimage-20240731152144771.png" alt="image-20240731152144771"></p>
<h4 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h4><p>先前的main.rs里已经有了程序入口,可尝试给<code>qemu-riscv64</code>跑一个看看</p>
<p><img src="/../pics/image-20240731183935657.png" alt="image-20240731183935657"></p>
<p>第一次跑段错误了,后面跟教程修改了一些才能够正常运行</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个神秘的函数,它通过使用内联汇编方便地使用core库提供给的系统调用.比如目前执行环境缺少一个退出机制:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define syscall</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>,args: [<span class="type">usize</span>;<span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再传给qemu就能正常运行,还能通过$?参数接受退出码</p>
<p>如果要实现Stdout,也是类似的,复杂一点:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::fmt;</span><br><span class="line"><span class="keyword">use</span> core::fmt::Write;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再基于这个封装实现stdout</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sys_write</span>(<span class="number">1</span>, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实此时已经可以通过print输出字符串了,就是类型上会有点别扭(毕竟没有标准库)</p>
<p>再来点看不懂的格式化宏</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看看输出效果了</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pics/image-20240731191217937.png" alt="image-20240731191217937"></p>
<p>此时如果想用objdump看看的话,就会发现多了特别多的依赖之类,而上面写的源码编译出来的东西(除了宏,宏的编译结果我没法直接看出来)只占其中一部分,我的objdump结果总共2000行,其中300行左右是我们的源码</p>
<h4 id="裸机环境"><a href="#裸机环境" class="headerlink" title="裸机环境"></a>裸机环境</h4><p>用qemu的&#96;qemu-system-riscv64模拟risc-v 64构建裸机环境,加载内核的命令:</p>
<ul>
<li><code>-bios $(bootloader)</code>加载bootloader,即rustSBI,</li>
<li><code>-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)</code>表示硬件内存中的特定位置即<code>$(KERNEL_ENTRY_PA)</code>放置了操作系统的二进制程序<code>$(KERNEL_BIN)</code>,entry_pa值是0x80200000</li>
</ul>
<p>当我们执行包含上述启动参数的 qemu-system-riscv64 软件，就意味给这台虚拟的 RISC-V64 计算机加电了。 此时，CPU 的其它通用寄存器清零，而 PC 会指向 <code>0x1000</code> 的位置，这里有固化在硬件中的一小段引导代码， 它会很快跳转到 <code>0x80000000</code> 的 RustSBI 处。 RustSBI完成硬件初始化后，会跳转到 <code>$(KERNEL_BIN)</code> 所在内存位置 <code>0x80200000</code> 处， 执行操作系统的第一条指令。</p>
<p>当在裸机环境运行时,需要有关机功能</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bootloader/rustsbi-qemu.bin 直接添加的SBI规范实现的二进制代码，给操作系统提供基本支持服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/sbi.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      core::arch::asm!(</span><br><span class="line">          <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SBI_SHUTDOWN: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“ecall”和上以迎接不同在于特权级:</p>
<p>User Mode &lt; Supervisor Mode &lt; Machine Mode,分别对应”应用程序\操作系统\RustSBI”</p>
<p>编译结果如下:(ctlr C无法退出,用了类似kill的工具)</p>
<p><img src="/../pics/image-20240803214636705.png" alt="image-20240803214636705"></p>
<p>用rust-readobj看:(valid是后面通过qemu正常自动退出的结果,invalid是目前这个卡住的)</p>
<p><img src="/../pics/image-20240803215319416.png" alt="image-20240803215319416"></p>
<p>发现其入口地址不是 RustSBI 约定的 <code>0x80200000</code>,需要修改内存布局</p>
<ol>
<li>增加链接脚本: 首先在cargo的配置文件中加入自己的链接脚本:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// os/.cargo/config</span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在os&#x2F;src&#x2F;新建一linker.ld:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化栈空间</li>
</ol>
<p>再在同一文件夹新建一个entry.asm,用以初始化栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack</span><br><span class="line">boot_stack:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>

<p>可以看到此时在初始化空间之后直接call了一个新函数<code>rust_main</code>,于是我们也要在main.rs内补充同名函数以满足</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再把原本的_start注释掉</p>
<ol start="3">
<li>再次编译并生成和运行,可以看到qemu成功退出</li>
</ol>
<p><img src="/../pics/image-20240803220838568.png" alt="image-20240803220838568"></p>
<p>再清空一下.bss段,关于为什么<img src="/../pics/image-20240803221451061.png" alt="image-20240803221451061"></p>
<p>清除的方法即增加在main.rs中的clear_bss()</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再经过一些对原项目的加工(Ctrl cv),终于能hello world了!</p>
<p><img src="/../pics/image-20240803232800786.png" alt="image-20240803232800786"></p>
<h3 id="rCore-ch2"><a href="#rCore-ch2" class="headerlink" title="rCore-ch2"></a>rCore-ch2</h3><h4 id="todo-What？"><a href="#todo-What？" class="headerlink" title="todo What？"></a>todo What？</h4><p>说实话我在看到这一章的时候挺茫然的，满篇的东西都是在介绍，不知道我要干什么。</p>
<p>那么来总结一下这一章书上的内容先：</p>
<blockquote>
<ol>
<li>批处理系统：多个程序打包到一起输入计算机，程序结束自动执行下一个。为避免出错时整个环境崩溃，引入特权级，分开用户、内核。</li>
<li>应用程序： 项目文件里准备了bin文件夹对应各个应用程序。每个程序在main函数内实现了用户程序的功能。使用的依赖对应lib.rs（类似于一个标准库）。lib.rs中定义了<code>_start</code>用于初始化应用程序</li>
<li>批处理: 内核通过<code>link_app.S</code>获知应用程序的数量和位置,通过<code>AppManager</code>来加载应用程序的二进制码.加载时需要清除缓存,清空内存,将二进制程序复制到正确位置.</li>
<li>特权转换: 特权被一些对应用的切换和监控操作需要,比如初始化,处理系统调用,应用出错的处理程序,结束程序时的切换</li>
</ol>
</blockquote>
<p>在看看程序跑一遍的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[ INFO] [kernel] .data [0x8020b000, 0x80228000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80238000, lower_bound=0x80228000</span><br><span class="line">[ERROR] [kernel] .bss [0x80238000, 0x80239000)</span><br><span class="line">[kernel] num_app = 7</span><br><span class="line">[kernel] app_0 [0x8020b048, 0x8020f0f0)</span><br><span class="line">[kernel] app_1 [0x8020f0f0, 0x80213198)</span><br><span class="line">[kernel] app_2 [0x80213198, 0x80217240)</span><br><span class="line">[kernel] app_3 [0x80217240, 0x8021b2e8)</span><br><span class="line">[kernel] app_4 [0x8021b2e8, 0x8021f390)</span><br><span class="line">[kernel] app_5 [0x8021f390, 0x80223438)</span><br><span class="line">[kernel] app_6 [0x80223438, 0x802274e0)</span><br><span class="line">[kernel] Loading app_0</span><br><span class="line">[kernel] PageFault in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_1</span><br><span class="line">[kernel] IllegalInstruction in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_2</span><br><span class="line">[kernel] IllegalInstruction in application, kernel killed it.</span><br><span class="line">[kernel] Loading app_3</span><br><span class="line">Hello, world from user mode program!</span><br><span class="line">[kernel] Loading app_4</span><br><span class="line">power_3 [10000/200000]</span><br><span class="line">power_3 [20000/200000]</span><br><span class="line">power_3 [30000/200000]</span><br><span class="line">power_3 [40000/200000]</span><br><span class="line">power_3 [50000/200000]</span><br><span class="line">power_3 [60000/200000]</span><br><span class="line">power_3 [70000/200000]</span><br><span class="line">power_3 [80000/200000]</span><br><span class="line">power_3 [90000/200000]</span><br><span class="line">power_3 [100000/200000]</span><br><span class="line">power_3 [110000/200000]</span><br><span class="line">power_3 [120000/200000]</span><br><span class="line">power_3 [130000/200000]</span><br><span class="line">power_3 [140000/200000]</span><br><span class="line">power_3 [150000/200000]</span><br><span class="line">power_3 [160000/200000]</span><br><span class="line">power_3 [170000/200000]</span><br><span class="line">power_3 [180000/200000]</span><br><span class="line">power_3 [190000/200000]</span><br><span class="line">power_3 [200000/200000]</span><br><span class="line">3^200000 = 871008973(MOD 998244353)</span><br><span class="line">Test power_3 OK!</span><br><span class="line">[kernel] Loading app_5</span><br><span class="line">power_5 [10000/140000]</span><br><span class="line">power_5 [20000/140000]</span><br><span class="line">power_5 [30000/140000]</span><br><span class="line">power_5 [40000/140000]</span><br><span class="line">power_5 [50000/140000]</span><br><span class="line">power_5 [60000/140000]</span><br><span class="line">power_5 [70000/140000]</span><br><span class="line">power_5 [80000/140000]</span><br><span class="line">power_5 [90000/140000]</span><br><span class="line">power_5 [100000/140000]</span><br><span class="line">power_5 [110000/140000]</span><br><span class="line">power_5 [120000/140000]</span><br><span class="line">power_5 [130000/140000]</span><br><span class="line">power_5 [140000/140000]</span><br><span class="line">5^140000 = 386471875(MOD 998244353)</span><br><span class="line">Test power_5 OK!</span><br><span class="line">[kernel] Loading app_6</span><br><span class="line">power_7 [10000/160000]</span><br><span class="line">power_7 [20000/160000]</span><br><span class="line">power_7 [30000/160000]</span><br><span class="line">power_7 [40000/160000]</span><br><span class="line">power_7 [50000/160000]</span><br><span class="line">power_7 [60000/160000]</span><br><span class="line">power_7 [70000/160000]</span><br><span class="line">power_7 [80000/160000]</span><br><span class="line">power_7 [90000/160000]</span><br><span class="line">power_7 [100000/160000]</span><br><span class="line">power_7 [110000/160000]</span><br><span class="line">power_7 [120000/160000]</span><br><span class="line">power_7 [130000/160000]</span><br><span class="line">power_7 [140000/160000]</span><br><span class="line">power_7 [150000/160000]</span><br><span class="line">power_7 [160000/160000]</span><br><span class="line">7^160000 = 667897727(MOD 998244353)</span><br><span class="line">Test power_7 OK!</span><br><span class="line">All applications completed!</span><br></pre></td></tr></table></figure>

<p>再跟着代码看看运行的过程经历了什么(也就是看看源码,不想自己敲的懒狗发言XD)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">stext</span>(); <span class="comment">// begin addr of text segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">etext</span>(); <span class="comment">// end addr of text segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">srodata</span>(); <span class="comment">// start addr of Read-Only data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">erodata</span>(); <span class="comment">// end addr of Read-Only data ssegment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sdata</span>(); <span class="comment">// start addr of data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">edata</span>(); <span class="comment">// end addr of data segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>(); <span class="comment">// start addr of BSS segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>(); <span class="comment">// end addr of BSS segment</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">boot_stack_lower_bound</span>(); <span class="comment">// stack lower bound</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">boot_stack_top</span>(); <span class="comment">// stack top</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    logging::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Hello, world!&quot;</span>);</span><br><span class="line">    trace!(</span><br><span class="line">        <span class="string">&quot;[kernel] .text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        stext <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        etext <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    debug!(</span><br><span class="line">        <span class="string">&quot;[kernel] .rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;[kernel] .data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    warn!(</span><br><span class="line">        <span class="string">&quot;[kernel] boot_stack top=bottom=&#123;:#x&#125;, lower_bound=&#123;:#x&#125;&quot;</span>,</span><br><span class="line">        boot_stack_top <span class="keyword">as</span> <span class="type">usize</span>, boot_stack_lower_bound <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    error!(<span class="string">&quot;[kernel] .bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sbss <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    trap::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    batch::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    batch::<span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>make run LOG=INFO</code>的指令,可以看到从helloworld到error这三行是这里的输出.main之后是两个init和一个run_next</p>
<h4 id="CodeReading-CorePart"><a href="#CodeReading-CorePart" class="headerlink" title="CodeReading-CorePart"></a>CodeReading-CorePart</h4><h5 id="1-trap"><a href="#1-trap" class="headerlink" title="1.trap"></a>1.trap</h5><p><img src="/../pics/image-20240808221732668.png" alt="image-20240808221732668"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(__alltraps <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的init原谅我不是很明白.在同级文件夹找到了<code>__alltraps</code>的具体内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/trap/trap.S</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(cx: &amp;mut TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure>

<p>感谢逐行的注释</p>
<p><img src="/../pics/image-20240808215516481.png" alt="image-20240808215516481"></p>
<p>从    <code>csrrw sp, sscratch, sp</code>可知这个函数执行时将从用户态转向内核态,此时在做用户栈到内核栈的转换,分配空间存储trapText,保存一些寄存器的值到内核栈上:比如x1,x3,x5~x31,t0(对应<code>sstatus</code> 寄存器,包含当前 CPU 的状态),t1(对应<code>sepc</code> 寄存器,包含trap发生时的程序计数器值),t2(对应与用户空间的sp),最后将sp的值赋给a0,传给<code>trap_handler</code>.总的来说就是在初始化处理trap的条件和特权转换</p>
<p>返回看os&#x2F;trap&#x2F;mod.rs之中的<code>stvec::write(__alltraps as usize, TrapMode::Direct);</code>这一行,将这个trap处理的程序地址写入<code>stvec</code>,控制trap处理代码的入口地址.也就是在<code>trap::init();</code>之后,我们可以调用<code>stvec</code>来处理所有的trap了</p>
<h5 id="2-batch"><a href="#2-batch" class="headerlink" title="2.batch"></a>2.batch</h5><p>这一小节的内容能和tutorial书中实现批处理系统这一节对应上.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_app_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_app_info</span>() &#123;</span><br><span class="line">    APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">print_app_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">            <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>);</span><br><span class="line">            app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">            AppManager &#123;</span><br><span class="line">                num_app,</span><br><span class="line">                current_app: <span class="number">0</span>,</span><br><span class="line">                app_start,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看这样一点代码.</p>
<p>这里调用的过程是init -&gt; print__app_info -&gt; APP_MANAGER 实例 -&gt; lazy_static 初始化 -&gt; print_app_info 方法。</p>
<p>下面是涉及到的rust语法</p>
<blockquote>
<p>lazy_static: 给静态变量延迟赋值的宏,在第一次被访问时完成赋值</p>
<p>UPsafeCell: 在单处理器中使用的数据结构,里面包含一个<code>RefCell&lt;T&gt;</code>,通过<code>.exclusive_access()</code>可访问这个数据的可变引用,能防止内部对象被重复借用</p>
<p>os::ptr::read_volatile: <code>pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T</code>,在保持内存不变的同时易失性地读取src的值</p>
<p>core::slice::from_raw_parts: <code>pub const unsafe fn from_raw_parts&lt;&#39;a, T&gt;(data: *const T, len: usize) -&gt; &amp;&#39;a [T]</code>根据指针和长度形成切片。<code>len</code> 参数是 <strong>元素</strong> 的数量，而不是字节数。</p>
</blockquote>
<p>仔细看lazy_static的初始化内容:</p>
<ol>
<li><p>声明了一个<code>_num_app</code>符号,在同级文件夹中的link_app.S中定义,这个文件在构建操作系统时,依据os&#x2F;build.rs自动生成,内容类似下面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_num_app:</span><br><span class="line">    .quad 7</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_5_start</span><br><span class="line">    .quad app_6_start</span><br><span class="line">    .quad app_6_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">    app_0_start:</span><br><span class="line">    .incbin &quot;../user/build/bin/ch2b_bad_address.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br></pre></td></tr></table></figure>

<p>由于<code>const MAX_APP_NUM: usize=16</code>,为指针切片app_start赋值时,将容纳小于此数的app个数,并将每个app的起始地址和最后一个app的结束地址存入切片</p>
</li>
<li><p>最后返回初始化成功的AppManager.这里的<code>num_app</code>的类型我有点不明白,因为对它赋值时,使用的是泛型也就是前一行的usize,然而存储0-16范围的数也需要统一使用usize吗?</p>
</li>
<li><p>调用print_app_info,依次输出app个数和每个app的内存地址</p>
</li>
</ol>
<h5 id="3-run-next-app"><a href="#3-run-next-app" class="headerlink" title="3.run_next_app"></a>3.run_next_app</h5><p>和上一小节同样在batch.rs之中,下面是来自tutorial的一段话</p>
<blockquote>
<p><code>AppManager</code> 的方法中， <code>print_app_info/get_current_app/move_to_next_app</code> 都相当简单直接，需要说明的是 <code>load_app</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_next_app</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_manager</span> = APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_app</span> = app_manager.<span class="title function_ invoke__">get_current_app</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.<span class="title function_ invoke__">load_app</span>(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.<span class="title function_ invoke__">move_to_next_app</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>(cx_addr: <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">load_app</span>(&amp;<span class="keyword">self</span>, app_id: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">            <span class="keyword">use</span> crate::board::QEMUExit;</span><br><span class="line">            crate::board::QEMU_EXIT_HANDLE.<span class="title function_ invoke__">exit_success</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">        <span class="comment">// clear app area</span></span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br><span class="line">        <span class="comment">// Memory fence about fetching the instruction memory</span></span><br><span class="line">        <span class="comment">// It is guaranteed that a subsequent instruction fetch must</span></span><br><span class="line">        <span class="comment">// observes all previous writes to the instruction memory.</span></span><br><span class="line">        <span class="comment">// Therefore, fence.i must be executed after we have loaded</span></span><br><span class="line">        <span class="comment">// the code of the next app into the instruction memory.</span></span><br><span class="line">        <span class="comment">// See also: riscv non-priv spec chapter 3, &#x27;Zifencei&#x27; extension.</span></span><br><span class="line">        asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>load</code>本身在需要载入应用程序时,先清空约定区域的内存,将应用的二进制文件载入,再清空缓存</p>
<p><img src="/../pics/image-20240810012942659.png" alt="image-20240810012942659"></p>
<p>整体来看,调用一个app的功能实现:</p>
<ol>
<li>借来一个appManager的可变引用,方便调用它的impl</li>
<li>load 一个current 对应的app,再current+&#x3D;1,drop掉appmanager</li>
</ol>
<p>当我只看到这些时会觉得drop得有点早了,后面都在干什么?<code>__restore</code>的定义在哪里?找了一下在一个有点意外的位置:os&#x2F;src&#x2F;trap&#x2F;trap.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>

<p>a0塞进sp,以及几个熟悉的寄存器的出现,这个<code>__restore</code>和<code>alltraps</code>太像了,功能上和<code>alltraps</code>相反,是从内核态转到用户态用的.</p>
<p>在看一眼__restore被用去干嘛:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>功能解释:</p>
<ol>
<li>TrapContext::app_init_context获取app起始地址和用户栈指针,用于创建TrapContext</li>
<li>KERNEL_STACK.push_context获取TrapContext本体,将它push进内核栈的栈顶,返回TrapContext的在内核栈中的可变引用</li>
<li>__restore读取TrapContext的数据并将 CPU 切换到用户模式同时恢复应用程序的状态.</li>
</ol>
<p>在<code>__restore</code>后,程序就直接跳转到了应用程序的第一行二进制指令处,后面就暂时没有内核的事了.但是,应用结束任务再调用<code>run_next_app</code>的部分还没有看到,以及具体的应用出错的处理,特权转换也有点模糊(在我脑子里)</p>
<h4 id="CodeReading-UserPart"><a href="#CodeReading-UserPart" class="headerlink" title="CodeReading-UserPart"></a>CodeReading-UserPart</h4><h5 id="1-start"><a href="#1-start" class="headerlink" title="1.__start"></a>1.__start</h5><p>位于user&#x2F;src&#x2F;lib.rs中的函数，是用户库的入口函数，也是0x80400000地址对应的最先执行的程序部分。下面是tutorial里给的案例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="number">2</span><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="number">3</span><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line"><span class="number">4</span>    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line"><span class="number">5</span>    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>而我文件夹里的是这个样子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>(argc: <span class="type">usize</span>, argv: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">str_start</span> =</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; ((argv + i * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = (<span class="number">0usize</span>..)</span><br><span class="line">            .<span class="title function_ invoke__">find</span>(|i| <span class="keyword">unsafe</span> &#123; ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>).<span class="title function_ invoke__">read_volatile</span>() == <span class="number">0</span> &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            core::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, len)</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>(argc, v.<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多出的部分是在初始化堆、解析命令行参数（虽然现在应该没有应用需要）</p>
<p>后面exit之前进入了main函数，而因为<code>pub extern &quot;C&quot; fn </code>，main不一定是同处于lib.rs的main，得根据实际链接时bin文件中的main符号对应的main函数来看，main之中的内容暂时不看</p>
<h5 id="2-exit"><a href="#2-exit" class="headerlink" title="2.exit"></a>2.exit</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    console::<span class="title function_ invoke__">flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一节的_start最后调用了这个函数。这个函数内部的sys_exit是包装好的sys_call,实际上是ecall的汇编指令（类似第一章但是有区别）</p>
<p><code>ecall</code>在用户态会触发<code>Environment call from U-mode</code>的异常，会把特权从U提到S，同时直接跳转到对应的处理程序.遗憾的是还是没有发现哪里会切换到下一个应用</p>
<h5 id="3-User-Supervisor"><a href="#3-User-Supervisor" class="headerlink" title="3.User -&gt; Supervisor"></a>3.User -&gt; Supervisor</h5><p>然而exit有所谓的exit_code,再顺藤摸瓜看看谁接收这个码,发现在os&#x2F;src&#x2F;syscall&#x2F;process.rs中发现了以下神奇代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! App management syscalls</span></span><br><span class="line"><span class="keyword">use</span> crate::batch::run_next_app;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// task exits and submit an exit code</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    trace!(<span class="string">&quot;[kernel] Application exited with code &#123;&#125;&quot;</span>, exit_code);</span><br><span class="line">    <span class="title function_ invoke__">run_next_app</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了,是谁调用了位于内核态的sys_exit?明明前面用户态调用的sys_exit是通过ecall实现的user&#x2F;src&#x2F;syscall.rs,这两个sys_exit是怎么最后联系在一起的?</p>
<p>再看看os&#x2F;src&#x2F;syscall&#x2F;mod.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall</span>(syscall_id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> syscall_id &#123;</span><br><span class="line">        SYSCALL_WRITE =&gt; <span class="title function_ invoke__">sys_write</span>(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, args[<span class="number">2</span>]),</span><br><span class="line">        SYSCALL_EXIT =&gt; <span class="title function_ invoke__">sys_exit</span>(args[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">i32</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到syscall在内核态的包装方式,接下来在os的代码里找syscall</p>
<p>在os&#x2F;src&#x2F;trap&#x2F;mod.rs中找到结果了</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里发现调用了syscall</p>
<p>这个<code>trap_handler</code>就是每个应用的终点,不论是应用报错被alltraps接手,还是正常退出,从exit开始,最后都走到这里结束应用程序的生命周期.</p>
<p>整体和tutorial的内容算是一一对应,但是之前的rustlings没有这么多unsafe的指针操作和汇编,嗦实话这一章看的我好费劲T_T</p>
<h3 id="rCore-ch3"><a href="#rCore-ch3" class="headerlink" title="rCore-ch3"></a>rCore-ch3</h3><p>这一章的任务是分时多任务系统。</p>
<p>分时多任务的情景之一就是在一个任务暂停运行（比如通过io设备打字输入）时切换其他任务执行，避免资源浪费。任务切换的情况和trap类似的地方在于上下文的保存，不同点在于不用特权转换。</p>
<p>先看看文档的内容：</p>
<h4 id="reading-guide"><a href="#reading-guide" class="headerlink" title="reading guide"></a>reading guide</h4><h5 id="1-多程序放置加载"><a href="#1-多程序放置加载" class="headerlink" title="1.多程序放置加载"></a>1.多程序放置加载</h5><p>能够切换任务，说明程序都加载到内存里面了。在案例中，通过<code>user/build.py</code>达到为每个应用定制起始地址。（所谓的定制是指指定起始地址0x80400000再给每个应用0x20000的空间。）再通过loader和task（这两类似上章的batch）加载和切换任务。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="comment">/// the rust entry-point of os</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">kernel_log_info</span>();</span><br><span class="line">    heap_alloc::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    loader::<span class="title function_ invoke__">load_apps</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">enable_timer_interrupt</span>();</span><br><span class="line">    timer::<span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">run_first_task</span>();</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in rust_main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是第三章的案例程序中内核的初始化过程，而loader在初始化时加载应用程序进内存。</p>
<h5 id="2-任务切换"><a href="#2-任务切换" class="headerlink" title="2.任务切换"></a>2.任务切换</h5><blockquote>
<p>任务切换与上一章提及的 Trap 控制流切换相比，有如下异同：</p>
<ul>
<li>与 Trap 切换不同，它不涉及特权级切换，部分由编译器完成；</li>
<li>与 Trap 切换相同，它对应用是透明的。</li>
</ul>
</blockquote>
<p>通过汇编的<code>__switch</code>函数实现保存转换任务上下文。上下文包括ra、sp、s0~11几个寄存器。传入<code>__switch</code>的参数通过a0和a1寄存器来传</p>
<p><img src="/../pics/image-20240820224140733.png" alt="image-20240820224140733"></p>
<blockquote>
<p>(from internet)</p>
<p>函数调用过程中可以直接改写的寄存器叫临时寄存器(t0<del>t6)。 在调用过程中不能直接改写的寄存器值得叫保存寄存器(s0</del>s11)，函数调用过程中如果要使用s0~s11，需要由被调用函数进行保护，保证在函数调用前后内部值不变。</p>
</blockquote>
<p>类似地，俺把任务切换当成函数之间的unsafe跳转来理解。</p>
<p>为了安全调用<code>__switch</code>，于是把它解释为Rust函数。编译器自己帮我们保存和回复caller保存寄存器。这样完整的上下文得到保存。</p>
<h5 id="3-管理多道程序"><a href="#3-管理多道程序" class="headerlink" title="3.管理多道程序"></a>3.管理多道程序</h5><blockquote>
<p>而内核为了管理任务，需要维护任务信息，相关内容包括：</p>
<ul>
<li>任务运行状态：未初始化、准备执行、正在执行、已退出</li>
<li>任务控制块：维护任务状态和任务上下文</li>
<li>任务相关系统调用：程序主动暂停 <code>sys_yield</code> 和主动退出 <code>sys_exit</code></li>
</ul>
</blockquote>
<p>代码挺多，细琐一下</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1// os/src/task/task.rs</span><br><span class="line">2</span><br><span class="line">3#[derive(Copy, Clone, PartialEq)]</span><br><span class="line">4pub enum TaskStatus &#123;</span><br><span class="line">5    UnInit, // 未初始化</span><br><span class="line">6    Ready, // 准备运行</span><br><span class="line">7    Running, // 正在运行</span><br><span class="line">8    Exited, // 已退出</span><br><span class="line">9&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>原文给出的任务运行状态。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1// os/src/task/task.rs</span><br><span class="line">2</span><br><span class="line">3#[derive(Copy, Clone)]</span><br><span class="line">4pub struct TaskControlBlock &#123;</span><br><span class="line">5    pub task_status: TaskStatus,</span><br><span class="line">6    pub task_cx: TaskContext,</span><br><span class="line">7&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以及任务控制块。（这个块就是内核中的应用管理单位）对其再封装一次：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// os/src/task/mod.rs</span><br><span class="line"></span><br><span class="line">pub struct TaskManager &#123;</span><br><span class="line">    num_app: usize,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TaskManagerInner &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: usize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于UpSafeCell这个结构，在第二章的batch源码reading部分有解释，能防止内部对象被重复借用，出现于单处理器。这层层封装是为了常量和变量分离。</p>
<p>初始化时将每个任务块状态设为ready并在内核栈压入一些初始化上下文，再更新<code>task_cx</code>即可。切换任务时，调用<code>sys_yield</code>或者<code>sys_exit</code>。后者需要传入一个应用码以print出退出的应用。这两个功能上都会切换到下一个应用。而切换到下一个应用是通过<code>__switch</code>实现的。由于使用了UpSafeCell，在改变<code>TaskManager.inner</code>并使用完其中参数后需要立刻drop它</p>
<h5 id="4-分时多任务"><a href="#4-分时多任务" class="headerlink" title="4.分时多任务"></a>4.分时多任务</h5><blockquote>
<p>现代的任务调度算法基本都是抢占式的，它要求每个应用只能连续执行一段时间，然后内核就会将它强制性切换出去。 一般将 <strong>时间片</strong> (Time Slice) 作为应用连续执行时长的度量单位，每个时间片可能在毫秒量级。 简单起见，我们使用 <strong>时间片轮转算法</strong> (RR, Round-Robin) 来对应用进行调度。</p>
</blockquote>
<p>挺神奇的一段话，信息量还挺足。这一节我恨不得全部cv，所以摸了，懒得写。</p>
<h4 id="coding-reporting"><a href="#coding-reporting" class="headerlink" title="coding&amp;reporting"></a>coding&amp;reporting</h4><p>![屏幕截图 2024-08-22 022814](..&#x2F;pics&#x2F;屏幕截图 2024-08-22 022814.png)</p>
<p>程序是通过了的，但是对于这个report有点疑问，就随便写了。</p>
<h3 id="rCore-ch4"><a href="#rCore-ch4" class="headerlink" title="rCore-ch4"></a>rCore-ch4</h3><p>看看修改了些什么</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1├── os</span><br><span class="line"> 2│   ├── ...</span><br><span class="line"> 3│   └── src</span><br><span class="line"> 4│       ├── ...</span><br><span class="line"> 5│       ├── config.rs(修改：新增一些内存管理的相关配置)</span><br><span class="line"> 6│       ├── linker.ld(修改：将跳板页引入内存布局)</span><br><span class="line"> 7│       ├── loader.rs(修改：仅保留获取应用数量和数据的功能)</span><br><span class="line"> 8│       ├── main.rs(修改)</span><br><span class="line"> 9│       ├── mm(新增：内存管理的 mm 子模块)</span><br><span class="line">10│       │   ├── address.rs(物理/虚拟 地址/页号的 Rust 抽象)</span><br><span class="line">11│       │   ├── frame_allocator.rs(物理页帧分配器)</span><br><span class="line">12│       │   ├── heap_allocator.rs(内核动态内存分配器)</span><br><span class="line">13│       │   ├── memory_set.rs(引入地址空间 MemorySet 及逻辑段 MemoryArea 等)</span><br><span class="line">14│       │   ├── mod.rs(定义了 mm 模块初始化方法 init)</span><br><span class="line">15│       │   └── page_table.rs(多级页表抽象 PageTable 以及其他内容)</span><br><span class="line">16│       ├── syscall</span><br><span class="line">17│       │   ├── fs.rs(修改：基于地址空间的 sys_write 实现)</span><br><span class="line">18│       │   ├── mod.rs</span><br><span class="line">19│       │   └── process.rs</span><br><span class="line">20│       ├── task</span><br><span class="line">21│       │   ├── context.rs(修改：构造一个跳转到不同位置的初始任务上下文)</span><br><span class="line">22│       │   ├── mod.rs(修改，详见文档)</span><br><span class="line">23│       │   ├── switch.rs</span><br><span class="line">24│       │   ├── switch.S</span><br><span class="line">25│       │   └── task.rs(修改，详见文档)</span><br><span class="line">26│       └── trap</span><br><span class="line">27│           ├── context.rs(修改：在 Trap 上下文中加入了更多内容)</span><br><span class="line">28│           ├── mod.rs(修改：基于地址空间修改了 Trap 机制，详见文档)</span><br><span class="line">29│           └── trap.S(修改：基于地址空间修改了 Trap 上下文保存与恢复汇编代码)</span><br><span class="line">30└── user</span><br><span class="line">31    ├── build.py(编译时不再使用)</span><br><span class="line">32    ├── ...</span><br><span class="line">33    └── src</span><br><span class="line">34        ├── linker.ld(修改：将所有应用放在各自地址空间中固定的位置)</span><br><span class="line">35        └── ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>再来一点Rall的解释，没有这个这一章的代码会有点读不懂</p>
<blockquote>
<p>RAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父 Bjarne Stroustrup 提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。</p>
</blockquote>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="1-页表及其工作机制"><a href="#1-页表及其工作机制" class="headerlink" title="1.页表及其工作机制"></a>1.页表及其工作机制</h5><p>当直接访问内存时，访问方式是段基址+偏移。当需要读入的内存过大时，连续物理内存的不足将使这种行为失败。过小时也会无法进行换入换出。为了将线性的地址和物理地址解绑，页表应运而生。</p>
<p>对内存分页时，相等大小的页代替了不等的段。而页表则是对每一个虚拟内存的检索替换，它在保持偏移值的同时，将虚拟的<strong>连续</strong>的段基址计算为<strong>不连续</strong>的物理地址的段基址。</p>
<p>比如sv39多级页表。</p>
<h5 id="2-sv39多级页表"><a href="#2-sv39多级页表" class="headerlink" title="2.sv39多级页表"></a>2.sv39多级页表</h5><p>首先，为了启用多级页表，需要修改 S 特权级的 <code>satp</code> CSR。</p>
<p>之后，MMU地址转换将所有的S&#x2F;U特权级的访存地址视为VPN（virtual page number），并替换为PPN（physical page number）</p>
<p>sv39即指将VPN视为39个有效位的虚拟地址，转化为56位的ppn</p>
<p><img src="/../pics/sv39-va-pa.png" alt="../_images/sv39-va-pa.png"></p>
<blockquote>
<p>VA:</p>
<p>[63..39]-&gt;与第38位相同，否则视为无效vpn</p>
<p>[38..12]-&gt;即VPN均分为三段，每段对应一级的页表查询</p>
<p>[11..0]-&gt;偏移值</p>
<p>PA:</p>
<p>[55..12]-&gt;即PPN，对应VPN的页表查询结果<br>[11..0]-&gt;和VA的偏移值相同</p>
</blockquote>
<p>具体的页表如图：</p>
<p><img src="/../pics/sv39-pte.png" alt="../_images/sv39-pte.png"></p>
<blockquote>
<p>[0..7]-&gt;标志位：{</p>
<ul>
<li>仅当 V(Valid) 位为 1 时，页表项才是合法的；</li>
<li>R&#x2F;W&#x2F;X 分别控制索引到这个页表项的对应虚拟页面是否允许读&#x2F;写&#x2F;取指；</li>
<li>U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li>
<li>G 我们不理会；</li>
<li>A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li>
<li>D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li>
</ul>
<p>}</p>
<p>[53..10]-&gt;页表存储的三段PPN</p>
</blockquote>
<h5 id="3-sv39-in-Code"><a href="#3-sv39-in-Code" class="headerlink" title="3.sv39 in Code"></a>3.sv39 in Code</h5><p>首先，代码里需要给定内存的可用部分。在os&#x2F;src&#x2F;config.rs中给定了内存的终止地址。<code>pub const MEMORY_END: usize = 0x80800000;</code>修改此地址可决定内存的大小。然后以0x80000000到MEMORY_END的区间传给FrameAllocator。</p>
<p>在实际运行时，需要对页帧进行分配和回收。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//os/src/frame-allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到对页帧分配的一些限制。如果成功就会直接返回<code>Some(PPN)</code></p>
<p>但这个代码没有<code>pub</code>，说明需要在封装一层。由于页帧在多线程中运行的特殊性，FRAME_ALLOCATOR被<code>UPsafecell</code>封装一层，同一时间仅允许一个线程进行页帧分配。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Allocate a physical page frame in FrameTracker style</span></span><br><span class="line"><span class="comment">// os/src/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的页帧使用方式则需要看调用这两个接口的程序部分。不过实际上页表以外调用的地方只有如下函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">            MapType::Identical =&gt; &#123;</span><br><span class="line">                ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MapType::Framed =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                ppn = frame.ppn;</span><br><span class="line">                <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>页帧在页表中被封装存储</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/os/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的FrameTracker即页帧，被基于rall原则的方法封装以保证它的生命周期</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new FrameTracker</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_array</span> = ppn.<span class="title function_ invoke__">get_bytes_array</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;FrameTracker:PPN=&#123;:#x&#125;&quot;</span>, <span class="keyword">self</span>.ppn.<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它只是ppn，只不过因为实现了一些trait比如drop，rust能够在其生命周期结束后被自动drop</p>
<p>回到页表，看看页表的方法们。虽然页表只有root_ppn和很多framed-tracker，但它的方法和pte关系很大（PageTableEntry）。比如find_pte_create，在映射了虚实内存之后按映射关系和页表公式取得pte，以及map，检验pte的有效与否<br>再看看下面pte的方法，pte能够获得flag和ppn，其实它已经是页表能获得的有效内存的结果，如图<img src="/../pics/sv39-pte.png" alt="../_images/sv39-pte.png"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Temporarily used to get arguments from user space.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_token</span>(satp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            root_ppn: PhysPageNum::<span class="title function_ invoke__">from</span>(satp &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)),</span><br><span class="line">            frames: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">                <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Find PageTableEntry by VirtPageNum</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//here got pte</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// bits of page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Create an empty page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">empty</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123; bits: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the physical page number from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the flags from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// The page pointered by page table entry is valid?</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_valid</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.<span class="title function_ invoke__">flags</span>() &amp; PTEFlags::V) != PTEFlags::<span class="title function_ invoke__">empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// The page pointered by page table entry is readable?</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">readable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.<span class="title function_ invoke__">flags</span>() &amp; PTEFlags::R) != PTEFlags::<span class="title function_ invoke__">empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// The page pointered by page table entry is writable?</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">writable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.<span class="title function_ invoke__">flags</span>() &amp; PTEFlags::W) != PTEFlags::<span class="title function_ invoke__">empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// The page pointered by page table entry is executable?</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">executable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.<span class="title function_ invoke__">flags</span>() &amp; PTEFlags::X) != PTEFlags::<span class="title function_ invoke__">empty</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-页表？页块！"><a href="#4-页表？页块！" class="headerlink" title="4.页表？页块！"></a>4.页表？页块！</h5><p>上述只是页表的部分，页表和内存的映射这里开始</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MapArea即逻辑段，意为一段连续（虚拟）地址的虚拟内存。其中包含的虚拟地址区间都是保证可以正确完成地址转换的，而且可读可写可执行（和物理地址功能上一致）。</p>
<p>其中的成员一一细说：</p>
<ol>
<li><p>vpn_range：即虚拟区间，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">VPNRange</span> = SimpleRange&lt;VirtPageNum&gt;;</span><br><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SimpleRange</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: StepByOne + <span class="built_in">Copy</span> + <span class="built_in">PartialEq</span> + <span class="built_in">PartialOrd</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    l: T,</span><br><span class="line">    r: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; SimpleRange&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: StepByOne + <span class="built_in">Copy</span> + <span class="built_in">PartialEq</span> + <span class="built_in">PartialOrd</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(start: T, end: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(start &lt;= end, <span class="string">&quot;start &#123;:?&#125; &gt; end &#123;:?&#125;!&quot;</span>, start, end);</span><br><span class="line">        <span class="keyword">Self</span> &#123; l: start, r: end &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_start</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">self</span>.l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_end</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">self</span>.r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>data_frames<br>就是如同上面一行所写的定义</p>
</li>
<li><p>map_type<br>有两种的枚举，Identical,Framed.分别代表恒等映射和新分配两种map方式。</p>
<blockquote>
<p>其中 <code>Identical</code> 表示之前也有提到的恒等映射，用于在启用多级页表之后仍能够访问一个特定的物理地址指向的物理内存；而 <code>Framed</code> 则表示对于每个虚拟页面都需要映射到一个新分配的物理页帧。</p>
<p>当逻辑段采用 <code>MapType::Framed</code> 方式映射到物理内存的时候， <code>data_frames</code> 是一个保存了该逻辑段内的每个虚拟页面 和它被映射到的物理页帧 <code>FrameTracker</code> 的一个键值对容器 <code>BTreeMap</code> 中，这些物理页帧被用来存放实际内存数据而不是 作为多级页表中的中间节点。和之前的 <code>PageTable</code> 一样，这也用到了 RAII 的思想，将这些物理页帧的生命周期绑定到它所在的逻辑段 <code>MapArea</code> 下，当逻辑段被回收之后这些之前分配的物理页帧也会自动地同时被回收。</p>
</blockquote>
</li>
<li><p>map_perm<br>4个flag的集合，和PTEFlags中的R、W、X、U</p>
</li>
</ol>
<p>那么这个映射虽然和vpn、ppn关系不小，但是没看到它怎么使用页表本身的代码。接下来是MemorySet,即地址空间。</p>
<blockquote>
<p><strong>地址空间</strong> 是一系列有关联的不一定连续的逻辑段，这种关联一般是指这些逻辑段组成的虚拟内存空间与一个运行的程序（目前把一个运行的程序称为任务，后续会称为进程）绑定，即这个运行的程序对代码和数据的直接访问范围限制在它关联的虚拟地址空间之内。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的方法有new_bare、token、push、insert_framed_area、用于初始化的new_kernel、和from_elf</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new empty `MemorySet`.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_bare</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            page_table: PageTable::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            areas: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the page table token</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">token</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">token</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Assume that no conflicts.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert_framed_area</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        start_va: VirtAddr,</span><br><span class="line">        end_va: VirtAddr,</span><br><span class="line">        permission: MapPermission,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, permission),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="type">Option</span>&lt;&amp;[<span class="type">u8</span>]&gt;) &#123;</span><br><span class="line">        map_area.<span class="title function_ invoke__">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = data &#123;</span><br><span class="line">            map_area.<span class="title function_ invoke__">copy_data</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.areas.<span class="title function_ invoke__">push</span>(map_area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Mention that trampoline is not collected by areas.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">map_trampoline</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(</span><br><span class="line">            VirtAddr::<span class="title function_ invoke__">from</span>(TRAMPOLINE).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            PhysAddr::<span class="title function_ invoke__">from</span>(strampoline <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            PTEFlags::R | PTEFlags::X,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Without kernel stacks.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="comment">/// Include sections in elf and trampoline and TrapContext and user stack,</span></span><br><span class="line">    <span class="comment">/// also returns user_sp and entry point.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_elf</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> (<span class="keyword">Self</span>, <span class="type">usize</span>, <span class="type">usize</span>);</span><br></pre></td></tr></table></figure>

<p>push能够在当前的memory_set插入一个新的逻辑段，并为framed映射的页帧写入初始值，然后insert_framed_area调用push</p>
<blockquote>
<p>注意该方法的调用者要保证同一地址空间内的任意两个逻辑段不能存在交集，从后面即将分别介绍的内核和应用的地址空间布局可以看出这一要求得到了保证；</p>
</blockquote>
<h4 id="真实地址空间初始化"><a href="#真实地址空间初始化" class="headerlink" title="真实地址空间初始化"></a>真实地址空间初始化</h4><p>当虚拟内存到物理内存的translate机制完善之后，我们可以尝试将所有的物理内存尝试以虚拟内存的方式初始化。</p>
<p>已知，内核代码的访存地址也是虚拟地址。则内核的各数据段访问也需要虚拟化。而这个过程还需要包含所有应用的内核栈以及跳板。</p>
<blockquote>
<p>内核的四个逻辑段 <code>.text/.rodata/.data/.bss</code> 被恒等映射到物理内存，这使得我们在无需调整内核内存布局 <code>os/src/linker.ld</code> 的情况下就仍能象启用页表机制之前那样访问内核的各个段。注意我们借用页表机制对这些逻辑段的访问方式做出了限制，这都是为了在硬件的帮助下能够尽可能发现内核中的 bug ，在这里：</p>
<ul>
<li>四个逻辑段的 U 标志位均未被设置，使得 CPU 只能在处于 S 特权级（或以上）时访问它们；</li>
<li>代码段 <code>.text</code> 不允许被修改；</li>
<li>只读数据段 <code>.rodata</code> 不允许被修改，也不允许从它上面取指执行；</li>
<li><code>.data/.bss</code> 均允许被读写，但是不允许从它上面取指执行。</li>
</ul>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stext</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">etext</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">srodata</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">erodata</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sdata</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">edata</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sbss_with_stack</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">strampoline</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="comment">/// Without kernel stacks.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// map kernel sections</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::X,</span><br><span class="line">        ), <span class="literal">None</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;mapping .rodata section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (srodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (erodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R,</span><br><span class="line">        ), <span class="literal">None</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;mapping .data section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sdata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (edata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ), <span class="literal">None</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;mapping .bss section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (ebss <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ), <span class="literal">None</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;mapping physical memory&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MEMORY_END.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ), <span class="literal">None</span>);</span><br><span class="line">        memory_set</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一串长不拉几的代码将在以下地方被使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这个静态初始化就是内核空间的初始化实现。</p>
<p>类似的，也可以初始化应用的地址空间。</p>
<h5 id="应用的地址空间"><a href="#应用的地址空间" class="headerlink" title="应用的地址空间"></a>应用的地址空间</h5><blockquote>
<p>在前面的章节中，我们直接将丢弃所有符号的应用二进制镜像链接到内核，在初始化的时候 内核仅需将他们加载到正确的初始物理地址就能使它们正确执行。但本章中，我们希望效仿内核地址空间的设计，同样借助页表机制 使得应用地址空间的各个逻辑段也可以有不同的访问方式限制，这样可以提早检测出应用的错误并及时将其终止以最小化它对系统带来的 恶劣影响。</p>
</blockquote>
<p>具体的说，之前的用户程序只是一个删去了符号等信息的bin文件，用很粗略的方法链接到对应空间里。而在虚拟内存的规范下，使用elf格式的应用已经是可行的。对应的代码修改有以下部分：</p>
<ol>
<li>loader模块</li>
<li>linker脚本（用户态的那个）</li>
</ol>
<p>elf格式的优势在于其格式规定的分段，每一段都有严格的权限限制，比如下面每一段的AX、AM等flag。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -S user/target/riscv64gc-unknown-none-elf/release/ch2b_hello_world</span><br><span class="line">.elf</span><br><span class="line">There are 8 section headers, starting at offset 0x5170:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00001000</span><br><span class="line">       000000000000272c  0000000000000000  AX       0     0     2</span><br><span class="line">  [ 2] .rodata           PROGBITS         0000000000003000  00004000</span><br><span class="line">       0000000000000a60  0000000000000000  AM       0     0     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000004000  00005000</span><br><span class="line">       00000000000000a8  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           00000000000040a8  000050a8</span><br><span class="line">       0000000000004139  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  000050a8</span><br><span class="line">       0000000000000048  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .riscv.attributes RISCV_ATTRIBUTE  0000000000000000  000050f0</span><br><span class="line">       000000000000003e  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .shstrtab         STRTAB           0000000000000000  0000512e</span><br><span class="line">       000000000000003f  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), p (processor specific)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/../pics/app-as-full.png" alt="../_images/app-as-full.png"></p>
<p>左侧给出了应用地址空间最低 256GiB 的布局：从 0x0 开始向高地址放置应用内存布局中的 各个逻辑段，最后放置带有一个保护页面的用户栈。这些逻辑段都是以 <code>Framed</code> 方式映射到物理内存的，从访问方式上来说都加上 了 U 标志位代表 CPU 可以在 U 特权级也就是执行应用代码的时候访问它们。</p>
</blockquote>
<h5 id="trap的变化"><a href="#trap的变化" class="headerlink" title="trap的变化"></a>trap的变化</h5><p>上一节的图中，trap被放在仅次于跳板的位置。看看mm的相关代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_elf</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> (<span class="keyword">Self</span>, <span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// map program headers of elf, with U flag</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">elf</span> = xmas_elf::ElfFile::<span class="title function_ invoke__">new</span>(elf_data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">elf_header</span> = elf.header;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">magic</span> = elf_header.pt1.magic;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(magic, [<span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>], <span class="string">&quot;invalid elf!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ph_count</span> = elf_header.pt2.<span class="title function_ invoke__">ph_count</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_end_vpn</span> = <span class="title function_ invoke__">VirtPageNum</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..ph_count &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ph</span> = elf.<span class="title function_ invoke__">program_header</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> ph.<span class="title function_ invoke__">get_type</span>().<span class="title function_ invoke__">unwrap</span>() == xmas_elf::program::Type::Load &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">start_va</span>: VirtAddr = (ph.<span class="title function_ invoke__">virtual_addr</span>() <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">end_va</span>: VirtAddr = ((ph.<span class="title function_ invoke__">virtual_addr</span>() + ph.<span class="title function_ invoke__">mem_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map_perm</span> = MapPermission::U;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">ph_flags</span> = ph.<span class="title function_ invoke__">flags</span>();</span><br><span class="line">                <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_read</span>() &#123;</span><br><span class="line">                    map_perm |= MapPermission::R;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_write</span>() &#123;</span><br><span class="line">                    map_perm |= MapPermission::W;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_execute</span>() &#123;</span><br><span class="line">                    map_perm |= MapPermission::X;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">map_area</span> = MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, map_perm);</span><br><span class="line">                max_end_vpn = map_area.vpn_range.<span class="title function_ invoke__">get_end</span>();</span><br><span class="line">                memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">                    map_area,</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(&amp;elf.input[ph.<span class="title function_ invoke__">offset</span>() <span class="keyword">as</span> <span class="type">usize</span>..(ph.<span class="title function_ invoke__">offset</span>() + ph.<span class="title function_ invoke__">file_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>]),</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// map user stack with U flags</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">max_end_va</span>: VirtAddr = max_end_vpn.<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_stack_bottom</span>: <span class="type">usize</span> = max_end_va.<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="comment">// guard page</span></span><br><span class="line">        user_stack_bottom += PAGE_SIZE;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">user_stack_top</span> = user_stack_bottom + USER_STACK_SIZE;</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                user_stack_bottom.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                user_stack_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Framed,</span><br><span class="line">                MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// used in sbrk</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                user_stack_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                user_stack_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Framed,</span><br><span class="line">                MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// map TrapContext</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                TRAP_CONTEXT_BASE.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                TRAMPOLINE.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Framed,</span><br><span class="line">                MapPermission::R | MapPermission::W,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        (</span><br><span class="line">            memory_set,</span><br><span class="line">            user_stack_top,</span><br><span class="line">            elf.header.pt2.<span class="title function_ invoke__">entry_point</span>() <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>不明白为什么先塞跳板再检查elf的魔数。确认elf有效之后，该函数再遍历elf头（如果是load），对每一段的程序按照flag类型修改对应maparea的flag，最后将程序加载入虚拟空间中。之后是处理用户栈，最后是压入trap和跳板。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://luvroc.github.io">luvroc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://luvroc.github.io/2024/07/31/rCore/">http://luvroc.github.io/2024/07/31/rCore/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://luvroc.github.io" target="_blank">uloveRock?</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a><a class="post-meta__tags" href="/tags/Embedded/">Embedded</a></div><div class="post_share"><div class="social-share" data-image="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/31/solana!/" title="solana资料和环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">solana资料和环境配置</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/30/firstMd/" title="隐私计算"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">隐私计算</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/31/solana!/" title="solana资料和环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="title">solana资料和环境配置</div></div></a></div><div><a href="/2024/08/01/solanaNotes/" title="solanaNotes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-01</div><div class="title">solanaNotes</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=2316139590&amp;s=640" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">luvroc</div><div class="author-info__description">dont look back in anger</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luvroc"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">八月主要更新solana和rCore-Tutorial</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch1"><span class="toc-number">1.</span> <span class="toc-text">rCore-ch1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">环境执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">用户态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">裸机环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch2"><span class="toc-number">2.</span> <span class="toc-text">rCore-ch2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#todo-What%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">todo What？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeReading-CorePart"><span class="toc-number">2.2.</span> <span class="toc-text">CodeReading-CorePart</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-trap"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.trap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-batch"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.batch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-run-next-app"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.run_next_app</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeReading-UserPart"><span class="toc-number">2.3.</span> <span class="toc-text">CodeReading-UserPart</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-start"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.__start</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-exit"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.exit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-User-Supervisor"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.User -&gt; Supervisor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch3"><span class="toc-number">3.</span> <span class="toc-text">rCore-ch3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reading-guide"><span class="toc-number">3.1.</span> <span class="toc-text">reading guide</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%9A%E7%A8%8B%E5%BA%8F%E6%94%BE%E7%BD%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.多程序放置加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.任务切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%AE%A1%E7%90%86%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.管理多道程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.分时多任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#coding-reporting"><span class="toc-number">3.2.</span> <span class="toc-text">coding&amp;reporting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rCore-ch4"><span class="toc-number">4.</span> <span class="toc-text">rCore-ch4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%B5%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.页表及其工作机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-sv39%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.sv39多级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-sv39-in-Code"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.sv39 in Code</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%A1%B5%E8%A1%A8%EF%BC%9F%E9%A1%B5%E5%9D%97%EF%BC%81"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.页表？页块！</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">真实地址空间初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">4.2.1.</span> <span class="toc-text">应用的地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#trap%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">4.2.2.</span> <span class="toc-text">trap的变化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/23/code%20with%20topic/" title="Code With Topic">Code With Topic</a><time datetime="2025-04-23T04:00:00.000Z" title="发表于 2025-04-23 12:00:00">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/23/model/" title="简历collect">简历collect</a><time datetime="2025-04-23T04:00:00.000Z" title="发表于 2025-04-23 12:00:00">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/23/code-Review/" title="code-Review">code-Review</a><time datetime="2025-04-23T04:00:00.000Z" title="发表于 2025-04-23 12:00:00">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/23/nihongo/" title="日语笔记">日语笔记</a><time datetime="2025-04-23T04:00:00.000Z" title="发表于 2025-04-23 12:00:00">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/01/solanaNotes/" title="solanaNotes">solanaNotes</a><time datetime="2024-07-31T18:35:00.000Z" title="发表于 2024-08-01 02:35:00">2024-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By luvroc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>